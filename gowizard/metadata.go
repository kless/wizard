// Copyright 2010  The "GoWizard" Authors
//
// Use of this source code is governed by the BSD-2 Clause license
// that can be found in the LICENSE file.
//
// This software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied. See the License
// for more details.

package main

import (
	"os"
	"path"
	"reflect"

	"github.com/kless/goconfig/config"
)

const _META_FILE = "Metadata"
const _VERSION = "1.1"

// Project types
var listProject = map[string]string{
	"cmd":  "Command line program",
	"pac":  "Package",
	"cgo":  "Package that calls C code",
}

// Available licenses
var listLicense = map[string]string{
	"apache-2": "Apache License, version 2.0",
	"bsd-2":    "BSD-2 Clause license",
	"bsd-3":    "BSD-3 Clause license",
	"cc0-1":    "Creative Commons CC0, version 1.0 Universal",
	"gpl-3":    "GNU General Public License, version 3 or later",
	"lgpl-3":   "GNU Lesser General Public License, version 3 or later",
	"agpl-3":   "GNU Affero General Public License, version 3 or later",
	"none":     "Proprietary license",
}

// Version control systems (VCS)
var listVCS = map[string]string{
	"bzr":   "Bazaar",
	"git":   "Git",
	"hg":    "Mercurial",
	"other": "other VCS",
	"none":  "none",
}

// === Errors
type MetadataFieldError string

func (self MetadataFieldError) String() string {
	return "metadata: default section has not field '" + string(self) + "'"
}
// ===

// Based on Metadata for Python Software Package, version 1.1
type Metadata struct {
	MetadataVersion string `tag:"metadata-version"` // Version of the file format
	ProjectType     string `tag:"project-type"`
	ProjectName     string `tag:"project-name"`
	PackageName     string `tag:"package-name"`
	Version         string `tag:"version"`
	Summary         string `tag:"summary"`
	DownloadURL     string `tag:"download-url"`
	Author          string `tag:"author"`
	AuthorEmail     string `tag:"author-email"`
	License         string `tag:"license"`
	VCS             string `tag:"vcs"`

	// === Optional
	//Platform string `tag:"platform"`
	//Description string `tag:"description"`
	Keywords string `tag:"keywords"`
	HomePage string `tag:"home-page"`
	//Classifier  []string `tag:"classifier"`

	// Configuration file
	cfg *config.Config
}

// Creates a new metadata with the basic fields to build the project.
func NewMetadata(ProjectType, ProjectName, PackageName, License, Author,
	AuthorEmail, vcs string) *Metadata {
	_Metadata := new(Metadata)
	_Metadata.cfg = config.NewDefault()

	_Metadata.MetadataVersion = _VERSION
	_Metadata.ProjectType = ProjectType
	_Metadata.ProjectName = ProjectName
	_Metadata.PackageName = PackageName
	_Metadata.License = License
	_Metadata.Author = Author
	_Metadata.AuthorEmail = AuthorEmail
	_Metadata.VCS = vcs

	return _Metadata
}

// Reads metadata file.
func ReadMetadata() (*Metadata, os.Error) {
	cfg, err := config.ReadDefault(_META_FILE)
	if err != nil {
		return nil, err
	}

	_Metadata := new(Metadata)

	_Metadata.MetadataVersion = _VERSION
	_Metadata.cfg = cfg

	// === Section 'CORE' has required fields.
	section := "CORE"

	field := "project-type"
	if s, err := cfg.String(section, field); err == nil {
		_Metadata.ProjectType = s
	} else {
		return nil, MetadataFieldError(field)
	}
	field = "project-name"
	if s, err := cfg.String(section, field); err == nil {
		_Metadata.ProjectName = s
	} else {
		return nil, MetadataFieldError(field)
	}
	field = "package-name"
	if s, err := cfg.String(section, field); err == nil {
		_Metadata.PackageName = s
	} else {
		return nil, MetadataFieldError(field)
	}
	field = "license"
	if s, err := cfg.String(section, field); err == nil {
		_Metadata.License = s
	} else {
		return nil, MetadataFieldError(field)
	}
	field = "vcs"
	if s, err := cfg.String(section, field); err == nil {
		_Metadata.VCS = s
	} else {
		return nil, MetadataFieldError(field)
	}

	section = "Main"
	// ===
	if s, err := cfg.String(section, "author"); err == nil {
		_Metadata.Author = s
	}
	if s, err := cfg.String(section, "author-email"); err == nil {
		_Metadata.AuthorEmail = s
	}
	if s, err := cfg.String(section, "version"); err == nil {
		_Metadata.Version = s
	}
	if s, err := cfg.String(section, "summary"); err == nil {
		_Metadata.Summary = s
	}
	if s, err := cfg.String(section, "download-url"); err == nil {
		_Metadata.DownloadURL = s
	}

	section = "Optional"
	// ===
	//if s, err := cfg.String(section, "platform"); err == nil {
	//_Metadata.Platform = s
	//}
	if s, err := cfg.String(section, "keywords"); err == nil {
		_Metadata.Keywords = s
	}
	if s, err := cfg.String(section, "home-page"); err == nil {
		_Metadata.HomePage = s
	}

	return _Metadata, nil
}

// Serializes to INI format and write it to file `_META_FILE` in directory `dir`.
func (self *Metadata) WriteINI(dir string) os.Error {
	header := "Generated by gowizard"
	reflectMetadata := self.getStruct()

	core := []string{
		"MetadataVersion",
		"ProjectType",
		"ProjectName",
		"PackageName",
		"License",
		"VCS",
	}

	main := []string{
		"Version",
		"Summary",
		"DownloadURL",
		"Author",
		"AuthorEmail",
	}

	optional := []string{
		//"Platform",
		//"Description",
		"HomePage",
		"Keywords",
		//"Classifier",
	}

	for i := 0; i < len(main); i++ {
		name, value := reflectMetadata.name_value(main[i])
		self.cfg.AddOption("Main", name, value)
	}

	for i := 0; i < len(optional); i++ {
		name, value := reflectMetadata.name_value(optional[i])
		self.cfg.AddOption("Optional", name, value)
	}

	for i := 0; i < len(core); i++ {
		name, value := reflectMetadata.name_value(core[i])
		self.cfg.AddOption("CORE", name, value)
	}

	filePath := path.Join(dir, _META_FILE)
	if err := self.cfg.WriteFile(filePath, PERM_FILE, header); err != nil {
		return err
	}

	return nil
}

// === Reflection
// ===

// To handle the reflection of a struct
type reflectStruct struct {
	strType  reflect.Type
	strValue reflect.Value
}

// Gets structs that represent the type 'Metadata'.
func (self *Metadata) getStruct() *reflectStruct {
	ptrValue := reflect.ValueOf(self)

	strType := ptrValue.Elem().Type()
	strValue := ptrValue.Elem()

	return &reflectStruct{strType, strValue}
}

// Gets tag or field name and its value, given the field name.
func (self *reflectStruct) name_value(fieldName string) (name, value string) {
	field, _ := self.strType.FieldByName(fieldName)
	value_ := self.strValue.FieldByName(fieldName)

	value = value_.String()

	if tag := field.Tag.Get("tag"); tag != "" {
		name = tag
	} else {
		name = field.Name
	}

	return
}
